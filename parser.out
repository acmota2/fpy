Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> all
Rule 1     all -> <empty>
Rule 2     all -> BEGIN END
Rule 3     all -> BEGIN body END
Rule 4     body -> statement
Rule 5     body -> body statement
Rule 6     statement -> function
Rule 7     statement -> ALIAS ID = typedesc
Rule 8     statement -> LET ID annotation = conditional
Rule 9     function -> FDEF prefix args returntype { compound }
Rule 10    function -> FDEF prefix args returntype { let_block compound }
Rule 11    args -> ( )
Rule 12    args -> ( arg_list )
Rule 13    arg_list -> lpattern annotation
Rule 14    arg_list -> arg_list , lpattern annotation
Rule 15    prefix -> ID
Rule 16    prefix -> [ SPECIALID ]
Rule 17    returntype -> <empty>
Rule 18    returntype -> RARROW typedesc
Rule 19    annotation -> <empty>
Rule 20    annotation -> : typedesc
Rule 21    typedesc -> typeid
Rule 22    typedesc -> typeclass
Rule 23    typedesc -> function_type
Rule 24    typedesc -> ( tuple_type )
Rule 25    typeclass -> TYPECLASS ID
Rule 26    function_type -> ( typedesc ) RARROW typedesc
Rule 27    function_type -> ( tuple_type ) RARROW typedesc
Rule 28    tuple_type -> typeid , typeid
Rule 29    tuple_type -> tuple_type , typeid
Rule 30    typeid -> INT
Rule 31    typeid -> FLOAT
Rule 32    typeid -> CHAR
Rule 33    typeid -> BOOL
Rule 34    typeid -> ID
Rule 35    typeid -> [ typedesc ]
Rule 36    let_block -> LET { let_cont }
Rule 37    let_cont -> assign
Rule 38    let_cont -> let_cont , assign
Rule 39    assign -> lpattern annotation = conditional
Rule 40    lpattern -> lvar
Rule 41    lpattern -> llist
Rule 42    lpattern -> ltuple
Rule 43    llist -> [ ]
Rule 44    llist -> [ pattern_list ]
Rule 45    llist -> [ lpattern | lpattern ]
Rule 46    pattern_list -> lpattern
Rule 47    pattern_list -> pattern_list , lpattern
Rule 48    ltuple -> ( )
Rule 49    ltuple -> ( ltuple_cont )
Rule 50    ltuple_cont -> lpattern , lpattern
Rule 51    ltuple_cont -> ltuple_cont , lpattern
Rule 52    lvar -> ID
Rule 53    lvar -> [ SPECIALID ]
Rule 54    lvar -> STRINGT
Rule 55    lvar -> INTT
Rule 56    lvar -> FLOATT
Rule 57    lvar -> CHART
Rule 58    lvar -> BOOLT
Rule 59    conditional -> compound
Rule 60    conditional -> IF conditional THEN conditional ELSE conditional
Rule 61    compound -> expression
Rule 62    compound -> compound infix expression
Rule 63    compound -> ( compound infix )
Rule 64    compound -> ( infix expression )
Rule 65    infix -> ` ID `
Rule 66    infix -> SPECIALID
Rule 67    expression -> multivar
Rule 68    expression -> lambda
Rule 69    expression -> cond_block
Rule 70    cond_block -> COND { cond , ELSE : conditional }
Rule 71    cond -> cond_singl
Rule 72    cond -> cond , cond_singl
Rule 73    cond_singl -> conditional : conditional
Rule 74    lambda -> FDEF ( ) { conditional }
Rule 75    lambda -> FDEF ( pattern_list ) { conditional }
Rule 76    multivar -> primaryvar
Rule 77    multivar -> rlist
Rule 78    multivar -> rtuple
Rule 79    multivar -> multivar ( condition_list )
Rule 80    primaryvar -> ID
Rule 81    primaryvar -> [ SPECIALID ]
Rule 82    primaryvar -> INTT
Rule 83    primaryvar -> FLOATT
Rule 84    primaryvar -> CHART
Rule 85    primaryvar -> STRINGT
Rule 86    primaryvar -> BOOLT
Rule 87    primaryvar -> ( conditional )
Rule 88    rtuple -> ( )
Rule 89    rtuple -> ( rtuple_cont )
Rule 90    rtuple_cont -> conditional , conditional
Rule 91    rtuple_cont -> rtuple_cont , conditional
Rule 92    rlist -> [ ]
Rule 93    rlist -> [ condition_list ]
Rule 94    rlist -> [ conditional | conditional ]
Rule 95    rlist -> [ conditional RANGER conditional ]
Rule 96    condition_list -> conditional
Rule 97    condition_list -> condition_list , conditional

Terminals, with rules where they appear

(                    : 11 12 24 26 27 48 49 63 64 74 75 79 87 88 89
)                    : 11 12 24 26 27 48 49 63 64 74 75 79 87 88 89
,                    : 14 28 29 38 47 50 51 70 72 90 91 97
:                    : 20 70 73
=                    : 7 8 39
ALIAS                : 7
BEGIN                : 2 3
BOOL                 : 33
BOOLT                : 58 86
CHAR                 : 32
CHART                : 57 84
COND                 : 70
ELSE                 : 60 70
END                  : 2 3
FDEF                 : 9 10 74 75
FLOAT                : 31
FLOATT               : 56 83
ID                   : 7 8 15 25 34 52 65 80
IF                   : 60
INT                  : 30
INTT                 : 55 82
LET                  : 8 36
RANGER               : 95
RARROW               : 18 26 27
SPECIALID            : 16 53 66 81
STRINGT              : 54 85
THEN                 : 60
TYPECLASS            : 25
[                    : 16 35 43 44 45 53 81 92 93 94 95
]                    : 16 35 43 44 45 53 81 92 93 94 95
`                    : 65 65
error                : 
{                    : 9 10 36 70 74 75
|                    : 45 94
}                    : 9 10 36 70 74 75

Nonterminals, with rules where they appear

all                  : 0
annotation           : 8 13 14 39
arg_list             : 12 14
args                 : 9 10
assign               : 37 38
body                 : 3 5
compound             : 9 10 59 62 63
cond                 : 70 72
cond_block           : 69
cond_singl           : 71 72
condition_list       : 79 93 97
conditional          : 8 39 60 60 60 70 73 73 74 75 87 90 90 91 94 94 95 95 96 97
expression           : 61 62 64
function             : 6
function_type        : 23
infix                : 62 63 64
lambda               : 68
let_block            : 10
let_cont             : 36 38
llist                : 41
lpattern             : 13 14 39 45 45 46 47 50 50 51
ltuple               : 42
ltuple_cont          : 49 51
lvar                 : 40
multivar             : 67 79
pattern_list         : 44 47 75
prefix               : 9 10
primaryvar           : 76
returntype           : 9 10
rlist                : 77
rtuple               : 78
rtuple_cont          : 89 91
statement            : 4 5
tuple_type           : 24 27 29
typeclass            : 22
typedesc             : 7 18 20 26 26 27 35
typeid               : 21 28 28 29

Parsing method: LALR

state 0

    (0) S' -> . all
    (1) all -> .
    (2) all -> . BEGIN END
    (3) all -> . BEGIN body END

    $end            reduce using rule 1 (all -> .)
    BEGIN           shift and go to state 2

    all                            shift and go to state 1

state 1

    (0) S' -> all .



state 2

    (2) all -> BEGIN . END
    (3) all -> BEGIN . body END
    (4) body -> . statement
    (5) body -> . body statement
    (6) statement -> . function
    (7) statement -> . ALIAS ID = typedesc
    (8) statement -> . LET ID annotation = conditional
    (9) function -> . FDEF prefix args returntype { compound }
    (10) function -> . FDEF prefix args returntype { let_block compound }

    END             shift and go to state 3
    ALIAS           shift and go to state 7
    LET             shift and go to state 8
    FDEF            shift and go to state 9

    body                           shift and go to state 4
    statement                      shift and go to state 5
    function                       shift and go to state 6

state 3

    (2) all -> BEGIN END .

    $end            reduce using rule 2 (all -> BEGIN END .)


state 4

    (3) all -> BEGIN body . END
    (5) body -> body . statement
    (6) statement -> . function
    (7) statement -> . ALIAS ID = typedesc
    (8) statement -> . LET ID annotation = conditional
    (9) function -> . FDEF prefix args returntype { compound }
    (10) function -> . FDEF prefix args returntype { let_block compound }

    END             shift and go to state 10
    ALIAS           shift and go to state 7
    LET             shift and go to state 8
    FDEF            shift and go to state 9

    statement                      shift and go to state 11
    function                       shift and go to state 6

state 5

    (4) body -> statement .

    END             reduce using rule 4 (body -> statement .)
    ALIAS           reduce using rule 4 (body -> statement .)
    LET             reduce using rule 4 (body -> statement .)
    FDEF            reduce using rule 4 (body -> statement .)


state 6

    (6) statement -> function .

    END             reduce using rule 6 (statement -> function .)
    ALIAS           reduce using rule 6 (statement -> function .)
    LET             reduce using rule 6 (statement -> function .)
    FDEF            reduce using rule 6 (statement -> function .)


state 7

    (7) statement -> ALIAS . ID = typedesc

    ID              shift and go to state 12


state 8

    (8) statement -> LET . ID annotation = conditional

    ID              shift and go to state 13


state 9

    (9) function -> FDEF . prefix args returntype { compound }
    (10) function -> FDEF . prefix args returntype { let_block compound }
    (15) prefix -> . ID
    (16) prefix -> . [ SPECIALID ]

    ID              shift and go to state 15
    [               shift and go to state 16

    prefix                         shift and go to state 14

state 10

    (3) all -> BEGIN body END .

    $end            reduce using rule 3 (all -> BEGIN body END .)


state 11

    (5) body -> body statement .

    END             reduce using rule 5 (body -> body statement .)
    ALIAS           reduce using rule 5 (body -> body statement .)
    LET             reduce using rule 5 (body -> body statement .)
    FDEF            reduce using rule 5 (body -> body statement .)


state 12

    (7) statement -> ALIAS ID . = typedesc

    =               shift and go to state 17


state 13

    (8) statement -> LET ID . annotation = conditional
    (19) annotation -> .
    (20) annotation -> . : typedesc

    =               reduce using rule 19 (annotation -> .)
    :               shift and go to state 19

    annotation                     shift and go to state 18

state 14

    (9) function -> FDEF prefix . args returntype { compound }
    (10) function -> FDEF prefix . args returntype { let_block compound }
    (11) args -> . ( )
    (12) args -> . ( arg_list )

    (               shift and go to state 21

    args                           shift and go to state 20

state 15

    (15) prefix -> ID .

    (               reduce using rule 15 (prefix -> ID .)


state 16

    (16) prefix -> [ . SPECIALID ]

    SPECIALID       shift and go to state 22


state 17

    (7) statement -> ALIAS ID = . typedesc
    (21) typedesc -> . typeid
    (22) typedesc -> . typeclass
    (23) typedesc -> . function_type
    (24) typedesc -> . ( tuple_type )
    (30) typeid -> . INT
    (31) typeid -> . FLOAT
    (32) typeid -> . CHAR
    (33) typeid -> . BOOL
    (34) typeid -> . ID
    (35) typeid -> . [ typedesc ]
    (25) typeclass -> . TYPECLASS ID
    (26) function_type -> . ( typedesc ) RARROW typedesc
    (27) function_type -> . ( tuple_type ) RARROW typedesc

    (               shift and go to state 28
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31
    BOOL            shift and go to state 32
    ID              shift and go to state 23
    [               shift and go to state 33
    TYPECLASS       shift and go to state 34

    typedesc                       shift and go to state 24
    typeid                         shift and go to state 25
    typeclass                      shift and go to state 26
    function_type                  shift and go to state 27

state 18

    (8) statement -> LET ID annotation . = conditional

    =               shift and go to state 35


state 19

    (20) annotation -> : . typedesc
    (21) typedesc -> . typeid
    (22) typedesc -> . typeclass
    (23) typedesc -> . function_type
    (24) typedesc -> . ( tuple_type )
    (30) typeid -> . INT
    (31) typeid -> . FLOAT
    (32) typeid -> . CHAR
    (33) typeid -> . BOOL
    (34) typeid -> . ID
    (35) typeid -> . [ typedesc ]
    (25) typeclass -> . TYPECLASS ID
    (26) function_type -> . ( typedesc ) RARROW typedesc
    (27) function_type -> . ( tuple_type ) RARROW typedesc

    (               shift and go to state 28
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31
    BOOL            shift and go to state 32
    ID              shift and go to state 23
    [               shift and go to state 33
    TYPECLASS       shift and go to state 34

    typedesc                       shift and go to state 36
    typeid                         shift and go to state 25
    typeclass                      shift and go to state 26
    function_type                  shift and go to state 27

state 20

    (9) function -> FDEF prefix args . returntype { compound }
    (10) function -> FDEF prefix args . returntype { let_block compound }
    (17) returntype -> .
    (18) returntype -> . RARROW typedesc

    {               reduce using rule 17 (returntype -> .)
    RARROW          shift and go to state 38

    returntype                     shift and go to state 37

state 21

    (11) args -> ( . )
    (12) args -> ( . arg_list )
    (13) arg_list -> . lpattern annotation
    (14) arg_list -> . arg_list , lpattern annotation
    (40) lpattern -> . lvar
    (41) lpattern -> . llist
    (42) lpattern -> . ltuple
    (52) lvar -> . ID
    (53) lvar -> . [ SPECIALID ]
    (54) lvar -> . STRINGT
    (55) lvar -> . INTT
    (56) lvar -> . FLOATT
    (57) lvar -> . CHART
    (58) lvar -> . BOOLT
    (43) llist -> . [ ]
    (44) llist -> . [ pattern_list ]
    (45) llist -> . [ lpattern | lpattern ]
    (48) ltuple -> . ( )
    (49) ltuple -> . ( ltuple_cont )

    )               shift and go to state 40
    ID              shift and go to state 46
    [               shift and go to state 47
    STRINGT         shift and go to state 48
    INTT            shift and go to state 49
    FLOATT          shift and go to state 50
    CHART           shift and go to state 51
    BOOLT           shift and go to state 52
    (               shift and go to state 39

    arg_list                       shift and go to state 41
    lpattern                       shift and go to state 42
    lvar                           shift and go to state 43
    llist                          shift and go to state 44
    ltuple                         shift and go to state 45

state 22

    (16) prefix -> [ SPECIALID . ]

    ]               shift and go to state 53


state 23

    (34) typeid -> ID .

    END             reduce using rule 34 (typeid -> ID .)
    ALIAS           reduce using rule 34 (typeid -> ID .)
    LET             reduce using rule 34 (typeid -> ID .)
    FDEF            reduce using rule 34 (typeid -> ID .)
    =               reduce using rule 34 (typeid -> ID .)
    )               reduce using rule 34 (typeid -> ID .)
    ,               reduce using rule 34 (typeid -> ID .)
    ]               reduce using rule 34 (typeid -> ID .)
    {               reduce using rule 34 (typeid -> ID .)


state 24

    (7) statement -> ALIAS ID = typedesc .

    END             reduce using rule 7 (statement -> ALIAS ID = typedesc .)
    ALIAS           reduce using rule 7 (statement -> ALIAS ID = typedesc .)
    LET             reduce using rule 7 (statement -> ALIAS ID = typedesc .)
    FDEF            reduce using rule 7 (statement -> ALIAS ID = typedesc .)


state 25

    (21) typedesc -> typeid .

    END             reduce using rule 21 (typedesc -> typeid .)
    ALIAS           reduce using rule 21 (typedesc -> typeid .)
    LET             reduce using rule 21 (typedesc -> typeid .)
    FDEF            reduce using rule 21 (typedesc -> typeid .)
    =               reduce using rule 21 (typedesc -> typeid .)
    )               reduce using rule 21 (typedesc -> typeid .)
    ,               reduce using rule 21 (typedesc -> typeid .)
    ]               reduce using rule 21 (typedesc -> typeid .)
    {               reduce using rule 21 (typedesc -> typeid .)


state 26

    (22) typedesc -> typeclass .

    END             reduce using rule 22 (typedesc -> typeclass .)
    ALIAS           reduce using rule 22 (typedesc -> typeclass .)
    LET             reduce using rule 22 (typedesc -> typeclass .)
    FDEF            reduce using rule 22 (typedesc -> typeclass .)
    =               reduce using rule 22 (typedesc -> typeclass .)
    )               reduce using rule 22 (typedesc -> typeclass .)
    ,               reduce using rule 22 (typedesc -> typeclass .)
    ]               reduce using rule 22 (typedesc -> typeclass .)
    {               reduce using rule 22 (typedesc -> typeclass .)


state 27

    (23) typedesc -> function_type .

    END             reduce using rule 23 (typedesc -> function_type .)
    ALIAS           reduce using rule 23 (typedesc -> function_type .)
    LET             reduce using rule 23 (typedesc -> function_type .)
    FDEF            reduce using rule 23 (typedesc -> function_type .)
    =               reduce using rule 23 (typedesc -> function_type .)
    )               reduce using rule 23 (typedesc -> function_type .)
    ,               reduce using rule 23 (typedesc -> function_type .)
    ]               reduce using rule 23 (typedesc -> function_type .)
    {               reduce using rule 23 (typedesc -> function_type .)


state 28

    (24) typedesc -> ( . tuple_type )
    (26) function_type -> ( . typedesc ) RARROW typedesc
    (27) function_type -> ( . tuple_type ) RARROW typedesc
    (28) tuple_type -> . typeid , typeid
    (29) tuple_type -> . tuple_type , typeid
    (21) typedesc -> . typeid
    (22) typedesc -> . typeclass
    (23) typedesc -> . function_type
    (24) typedesc -> . ( tuple_type )
    (30) typeid -> . INT
    (31) typeid -> . FLOAT
    (32) typeid -> . CHAR
    (33) typeid -> . BOOL
    (34) typeid -> . ID
    (35) typeid -> . [ typedesc ]
    (25) typeclass -> . TYPECLASS ID
    (26) function_type -> . ( typedesc ) RARROW typedesc
    (27) function_type -> . ( tuple_type ) RARROW typedesc

    (               shift and go to state 28
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31
    BOOL            shift and go to state 32
    ID              shift and go to state 23
    [               shift and go to state 33
    TYPECLASS       shift and go to state 34

    tuple_type                     shift and go to state 54
    typedesc                       shift and go to state 55
    typeid                         shift and go to state 56
    typeclass                      shift and go to state 26
    function_type                  shift and go to state 27

state 29

    (30) typeid -> INT .

    END             reduce using rule 30 (typeid -> INT .)
    ALIAS           reduce using rule 30 (typeid -> INT .)
    LET             reduce using rule 30 (typeid -> INT .)
    FDEF            reduce using rule 30 (typeid -> INT .)
    =               reduce using rule 30 (typeid -> INT .)
    )               reduce using rule 30 (typeid -> INT .)
    ,               reduce using rule 30 (typeid -> INT .)
    ]               reduce using rule 30 (typeid -> INT .)
    {               reduce using rule 30 (typeid -> INT .)


state 30

    (31) typeid -> FLOAT .

    END             reduce using rule 31 (typeid -> FLOAT .)
    ALIAS           reduce using rule 31 (typeid -> FLOAT .)
    LET             reduce using rule 31 (typeid -> FLOAT .)
    FDEF            reduce using rule 31 (typeid -> FLOAT .)
    =               reduce using rule 31 (typeid -> FLOAT .)
    )               reduce using rule 31 (typeid -> FLOAT .)
    ,               reduce using rule 31 (typeid -> FLOAT .)
    ]               reduce using rule 31 (typeid -> FLOAT .)
    {               reduce using rule 31 (typeid -> FLOAT .)


state 31

    (32) typeid -> CHAR .

    END             reduce using rule 32 (typeid -> CHAR .)
    ALIAS           reduce using rule 32 (typeid -> CHAR .)
    LET             reduce using rule 32 (typeid -> CHAR .)
    FDEF            reduce using rule 32 (typeid -> CHAR .)
    =               reduce using rule 32 (typeid -> CHAR .)
    )               reduce using rule 32 (typeid -> CHAR .)
    ,               reduce using rule 32 (typeid -> CHAR .)
    ]               reduce using rule 32 (typeid -> CHAR .)
    {               reduce using rule 32 (typeid -> CHAR .)


state 32

    (33) typeid -> BOOL .

    END             reduce using rule 33 (typeid -> BOOL .)
    ALIAS           reduce using rule 33 (typeid -> BOOL .)
    LET             reduce using rule 33 (typeid -> BOOL .)
    FDEF            reduce using rule 33 (typeid -> BOOL .)
    =               reduce using rule 33 (typeid -> BOOL .)
    )               reduce using rule 33 (typeid -> BOOL .)
    ,               reduce using rule 33 (typeid -> BOOL .)
    ]               reduce using rule 33 (typeid -> BOOL .)
    {               reduce using rule 33 (typeid -> BOOL .)


state 33

    (35) typeid -> [ . typedesc ]
    (21) typedesc -> . typeid
    (22) typedesc -> . typeclass
    (23) typedesc -> . function_type
    (24) typedesc -> . ( tuple_type )
    (30) typeid -> . INT
    (31) typeid -> . FLOAT
    (32) typeid -> . CHAR
    (33) typeid -> . BOOL
    (34) typeid -> . ID
    (35) typeid -> . [ typedesc ]
    (25) typeclass -> . TYPECLASS ID
    (26) function_type -> . ( typedesc ) RARROW typedesc
    (27) function_type -> . ( tuple_type ) RARROW typedesc

    (               shift and go to state 28
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31
    BOOL            shift and go to state 32
    ID              shift and go to state 23
    [               shift and go to state 33
    TYPECLASS       shift and go to state 34

    typedesc                       shift and go to state 57
    typeid                         shift and go to state 25
    typeclass                      shift and go to state 26
    function_type                  shift and go to state 27

state 34

    (25) typeclass -> TYPECLASS . ID

    ID              shift and go to state 58


state 35

    (8) statement -> LET ID annotation = . conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 60
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 36

    (20) annotation -> : typedesc .

    =               reduce using rule 20 (annotation -> : typedesc .)
    )               reduce using rule 20 (annotation -> : typedesc .)
    ,               reduce using rule 20 (annotation -> : typedesc .)


state 37

    (9) function -> FDEF prefix args returntype . { compound }
    (10) function -> FDEF prefix args returntype . { let_block compound }

    {               shift and go to state 79


state 38

    (18) returntype -> RARROW . typedesc
    (21) typedesc -> . typeid
    (22) typedesc -> . typeclass
    (23) typedesc -> . function_type
    (24) typedesc -> . ( tuple_type )
    (30) typeid -> . INT
    (31) typeid -> . FLOAT
    (32) typeid -> . CHAR
    (33) typeid -> . BOOL
    (34) typeid -> . ID
    (35) typeid -> . [ typedesc ]
    (25) typeclass -> . TYPECLASS ID
    (26) function_type -> . ( typedesc ) RARROW typedesc
    (27) function_type -> . ( tuple_type ) RARROW typedesc

    (               shift and go to state 28
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31
    BOOL            shift and go to state 32
    ID              shift and go to state 23
    [               shift and go to state 33
    TYPECLASS       shift and go to state 34

    typedesc                       shift and go to state 80
    typeid                         shift and go to state 25
    typeclass                      shift and go to state 26
    function_type                  shift and go to state 27

state 39

    (48) ltuple -> ( . )
    (49) ltuple -> ( . ltuple_cont )
    (50) ltuple_cont -> . lpattern , lpattern
    (51) ltuple_cont -> . ltuple_cont , lpattern
    (40) lpattern -> . lvar
    (41) lpattern -> . llist
    (42) lpattern -> . ltuple
    (52) lvar -> . ID
    (53) lvar -> . [ SPECIALID ]
    (54) lvar -> . STRINGT
    (55) lvar -> . INTT
    (56) lvar -> . FLOATT
    (57) lvar -> . CHART
    (58) lvar -> . BOOLT
    (43) llist -> . [ ]
    (44) llist -> . [ pattern_list ]
    (45) llist -> . [ lpattern | lpattern ]
    (48) ltuple -> . ( )
    (49) ltuple -> . ( ltuple_cont )

    )               shift and go to state 81
    ID              shift and go to state 46
    [               shift and go to state 47
    STRINGT         shift and go to state 48
    INTT            shift and go to state 49
    FLOATT          shift and go to state 50
    CHART           shift and go to state 51
    BOOLT           shift and go to state 52
    (               shift and go to state 39

    ltuple_cont                    shift and go to state 82
    lpattern                       shift and go to state 83
    lvar                           shift and go to state 43
    llist                          shift and go to state 44
    ltuple                         shift and go to state 45

state 40

    (11) args -> ( ) .

    RARROW          reduce using rule 11 (args -> ( ) .)
    {               reduce using rule 11 (args -> ( ) .)


state 41

    (12) args -> ( arg_list . )
    (14) arg_list -> arg_list . , lpattern annotation

    )               shift and go to state 84
    ,               shift and go to state 85


state 42

    (13) arg_list -> lpattern . annotation
    (19) annotation -> .
    (20) annotation -> . : typedesc

    )               reduce using rule 19 (annotation -> .)
    ,               reduce using rule 19 (annotation -> .)
    :               shift and go to state 19

    annotation                     shift and go to state 86

state 43

    (40) lpattern -> lvar .

    :               reduce using rule 40 (lpattern -> lvar .)
    )               reduce using rule 40 (lpattern -> lvar .)
    ,               reduce using rule 40 (lpattern -> lvar .)
    |               reduce using rule 40 (lpattern -> lvar .)
    ]               reduce using rule 40 (lpattern -> lvar .)
    =               reduce using rule 40 (lpattern -> lvar .)


state 44

    (41) lpattern -> llist .

    :               reduce using rule 41 (lpattern -> llist .)
    )               reduce using rule 41 (lpattern -> llist .)
    ,               reduce using rule 41 (lpattern -> llist .)
    |               reduce using rule 41 (lpattern -> llist .)
    ]               reduce using rule 41 (lpattern -> llist .)
    =               reduce using rule 41 (lpattern -> llist .)


state 45

    (42) lpattern -> ltuple .

    :               reduce using rule 42 (lpattern -> ltuple .)
    )               reduce using rule 42 (lpattern -> ltuple .)
    ,               reduce using rule 42 (lpattern -> ltuple .)
    |               reduce using rule 42 (lpattern -> ltuple .)
    ]               reduce using rule 42 (lpattern -> ltuple .)
    =               reduce using rule 42 (lpattern -> ltuple .)


state 46

    (52) lvar -> ID .

    :               reduce using rule 52 (lvar -> ID .)
    )               reduce using rule 52 (lvar -> ID .)
    ,               reduce using rule 52 (lvar -> ID .)
    |               reduce using rule 52 (lvar -> ID .)
    ]               reduce using rule 52 (lvar -> ID .)
    =               reduce using rule 52 (lvar -> ID .)


state 47

    (53) lvar -> [ . SPECIALID ]
    (43) llist -> [ . ]
    (44) llist -> [ . pattern_list ]
    (45) llist -> [ . lpattern | lpattern ]
    (46) pattern_list -> . lpattern
    (47) pattern_list -> . pattern_list , lpattern
    (40) lpattern -> . lvar
    (41) lpattern -> . llist
    (42) lpattern -> . ltuple
    (52) lvar -> . ID
    (53) lvar -> . [ SPECIALID ]
    (54) lvar -> . STRINGT
    (55) lvar -> . INTT
    (56) lvar -> . FLOATT
    (57) lvar -> . CHART
    (58) lvar -> . BOOLT
    (43) llist -> . [ ]
    (44) llist -> . [ pattern_list ]
    (45) llist -> . [ lpattern | lpattern ]
    (48) ltuple -> . ( )
    (49) ltuple -> . ( ltuple_cont )

    SPECIALID       shift and go to state 87
    ]               shift and go to state 88
    ID              shift and go to state 46
    [               shift and go to state 47
    STRINGT         shift and go to state 48
    INTT            shift and go to state 49
    FLOATT          shift and go to state 50
    CHART           shift and go to state 51
    BOOLT           shift and go to state 52
    (               shift and go to state 39

    pattern_list                   shift and go to state 89
    lpattern                       shift and go to state 90
    lvar                           shift and go to state 43
    llist                          shift and go to state 44
    ltuple                         shift and go to state 45

state 48

    (54) lvar -> STRINGT .

    :               reduce using rule 54 (lvar -> STRINGT .)
    )               reduce using rule 54 (lvar -> STRINGT .)
    ,               reduce using rule 54 (lvar -> STRINGT .)
    |               reduce using rule 54 (lvar -> STRINGT .)
    ]               reduce using rule 54 (lvar -> STRINGT .)
    =               reduce using rule 54 (lvar -> STRINGT .)


state 49

    (55) lvar -> INTT .

    :               reduce using rule 55 (lvar -> INTT .)
    )               reduce using rule 55 (lvar -> INTT .)
    ,               reduce using rule 55 (lvar -> INTT .)
    |               reduce using rule 55 (lvar -> INTT .)
    ]               reduce using rule 55 (lvar -> INTT .)
    =               reduce using rule 55 (lvar -> INTT .)


state 50

    (56) lvar -> FLOATT .

    :               reduce using rule 56 (lvar -> FLOATT .)
    )               reduce using rule 56 (lvar -> FLOATT .)
    ,               reduce using rule 56 (lvar -> FLOATT .)
    |               reduce using rule 56 (lvar -> FLOATT .)
    ]               reduce using rule 56 (lvar -> FLOATT .)
    =               reduce using rule 56 (lvar -> FLOATT .)


state 51

    (57) lvar -> CHART .

    :               reduce using rule 57 (lvar -> CHART .)
    )               reduce using rule 57 (lvar -> CHART .)
    ,               reduce using rule 57 (lvar -> CHART .)
    |               reduce using rule 57 (lvar -> CHART .)
    ]               reduce using rule 57 (lvar -> CHART .)
    =               reduce using rule 57 (lvar -> CHART .)


state 52

    (58) lvar -> BOOLT .

    :               reduce using rule 58 (lvar -> BOOLT .)
    )               reduce using rule 58 (lvar -> BOOLT .)
    ,               reduce using rule 58 (lvar -> BOOLT .)
    |               reduce using rule 58 (lvar -> BOOLT .)
    ]               reduce using rule 58 (lvar -> BOOLT .)
    =               reduce using rule 58 (lvar -> BOOLT .)


state 53

    (16) prefix -> [ SPECIALID ] .

    (               reduce using rule 16 (prefix -> [ SPECIALID ] .)


state 54

    (24) typedesc -> ( tuple_type . )
    (27) function_type -> ( tuple_type . ) RARROW typedesc
    (29) tuple_type -> tuple_type . , typeid

    )               shift and go to state 91
    ,               shift and go to state 92


state 55

    (26) function_type -> ( typedesc . ) RARROW typedesc

    )               shift and go to state 93


state 56

    (28) tuple_type -> typeid . , typeid
    (21) typedesc -> typeid .

    ,               shift and go to state 94
    )               reduce using rule 21 (typedesc -> typeid .)


state 57

    (35) typeid -> [ typedesc . ]

    ]               shift and go to state 95


state 58

    (25) typeclass -> TYPECLASS ID .

    END             reduce using rule 25 (typeclass -> TYPECLASS ID .)
    ALIAS           reduce using rule 25 (typeclass -> TYPECLASS ID .)
    LET             reduce using rule 25 (typeclass -> TYPECLASS ID .)
    FDEF            reduce using rule 25 (typeclass -> TYPECLASS ID .)
    =               reduce using rule 25 (typeclass -> TYPECLASS ID .)
    )               reduce using rule 25 (typeclass -> TYPECLASS ID .)
    ,               reduce using rule 25 (typeclass -> TYPECLASS ID .)
    ]               reduce using rule 25 (typeclass -> TYPECLASS ID .)
    {               reduce using rule 25 (typeclass -> TYPECLASS ID .)


state 59

    (80) primaryvar -> ID .

    (               reduce using rule 80 (primaryvar -> ID .)
    `               reduce using rule 80 (primaryvar -> ID .)
    SPECIALID       reduce using rule 80 (primaryvar -> ID .)
    END             reduce using rule 80 (primaryvar -> ID .)
    ALIAS           reduce using rule 80 (primaryvar -> ID .)
    LET             reduce using rule 80 (primaryvar -> ID .)
    FDEF            reduce using rule 80 (primaryvar -> ID .)
    THEN            reduce using rule 80 (primaryvar -> ID .)
    )               reduce using rule 80 (primaryvar -> ID .)
    ,               reduce using rule 80 (primaryvar -> ID .)
    |               reduce using rule 80 (primaryvar -> ID .)
    RANGER          reduce using rule 80 (primaryvar -> ID .)
    ]               reduce using rule 80 (primaryvar -> ID .)
    }               reduce using rule 80 (primaryvar -> ID .)
    :               reduce using rule 80 (primaryvar -> ID .)
    ELSE            reduce using rule 80 (primaryvar -> ID .)


state 60

    (8) statement -> LET ID annotation = conditional .

    END             reduce using rule 8 (statement -> LET ID annotation = conditional .)
    ALIAS           reduce using rule 8 (statement -> LET ID annotation = conditional .)
    LET             reduce using rule 8 (statement -> LET ID annotation = conditional .)
    FDEF            reduce using rule 8 (statement -> LET ID annotation = conditional .)


state 61

    (59) conditional -> compound .
    (62) compound -> compound . infix expression
    (65) infix -> . ` ID `
    (66) infix -> . SPECIALID

    END             reduce using rule 59 (conditional -> compound .)
    ALIAS           reduce using rule 59 (conditional -> compound .)
    LET             reduce using rule 59 (conditional -> compound .)
    FDEF            reduce using rule 59 (conditional -> compound .)
    THEN            reduce using rule 59 (conditional -> compound .)
    |               reduce using rule 59 (conditional -> compound .)
    RANGER          reduce using rule 59 (conditional -> compound .)
    ]               reduce using rule 59 (conditional -> compound .)
    ,               reduce using rule 59 (conditional -> compound .)
    )               reduce using rule 59 (conditional -> compound .)
    :               reduce using rule 59 (conditional -> compound .)
    ELSE            reduce using rule 59 (conditional -> compound .)
    }               reduce using rule 59 (conditional -> compound .)
    `               shift and go to state 97
    SPECIALID       shift and go to state 98

    infix                          shift and go to state 96

state 62

    (60) conditional -> IF . conditional THEN conditional ELSE conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 99
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 63

    (61) compound -> expression .

    `               reduce using rule 61 (compound -> expression .)
    SPECIALID       reduce using rule 61 (compound -> expression .)
    END             reduce using rule 61 (compound -> expression .)
    ALIAS           reduce using rule 61 (compound -> expression .)
    LET             reduce using rule 61 (compound -> expression .)
    FDEF            reduce using rule 61 (compound -> expression .)
    THEN            reduce using rule 61 (compound -> expression .)
    )               reduce using rule 61 (compound -> expression .)
    ,               reduce using rule 61 (compound -> expression .)
    |               reduce using rule 61 (compound -> expression .)
    RANGER          reduce using rule 61 (compound -> expression .)
    ]               reduce using rule 61 (compound -> expression .)
    }               reduce using rule 61 (compound -> expression .)
    :               reduce using rule 61 (compound -> expression .)
    ELSE            reduce using rule 61 (compound -> expression .)


state 64

    (63) compound -> ( . compound infix )
    (64) compound -> ( . infix expression )
    (87) primaryvar -> ( . conditional )
    (88) rtuple -> ( . )
    (89) rtuple -> ( . rtuple_cont )
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (65) infix -> . ` ID `
    (66) infix -> . SPECIALID
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (90) rtuple_cont -> . conditional , conditional
    (91) rtuple_cont -> . rtuple_cont , conditional
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    )               shift and go to state 102
    (               shift and go to state 64
    `               shift and go to state 97
    SPECIALID       shift and go to state 98
    IF              shift and go to state 62
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    compound                       shift and go to state 100
    infix                          shift and go to state 101
    expression                     shift and go to state 63
    conditional                    shift and go to state 103
    rtuple_cont                    shift and go to state 104
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 65

    (67) expression -> multivar .
    (79) multivar -> multivar . ( condition_list )

    `               reduce using rule 67 (expression -> multivar .)
    SPECIALID       reduce using rule 67 (expression -> multivar .)
    END             reduce using rule 67 (expression -> multivar .)
    ALIAS           reduce using rule 67 (expression -> multivar .)
    LET             reduce using rule 67 (expression -> multivar .)
    FDEF            reduce using rule 67 (expression -> multivar .)
    THEN            reduce using rule 67 (expression -> multivar .)
    )               reduce using rule 67 (expression -> multivar .)
    ,               reduce using rule 67 (expression -> multivar .)
    |               reduce using rule 67 (expression -> multivar .)
    RANGER          reduce using rule 67 (expression -> multivar .)
    ]               reduce using rule 67 (expression -> multivar .)
    }               reduce using rule 67 (expression -> multivar .)
    :               reduce using rule 67 (expression -> multivar .)
    ELSE            reduce using rule 67 (expression -> multivar .)
    (               shift and go to state 105


state 66

    (68) expression -> lambda .

    `               reduce using rule 68 (expression -> lambda .)
    SPECIALID       reduce using rule 68 (expression -> lambda .)
    END             reduce using rule 68 (expression -> lambda .)
    ALIAS           reduce using rule 68 (expression -> lambda .)
    LET             reduce using rule 68 (expression -> lambda .)
    FDEF            reduce using rule 68 (expression -> lambda .)
    THEN            reduce using rule 68 (expression -> lambda .)
    )               reduce using rule 68 (expression -> lambda .)
    ,               reduce using rule 68 (expression -> lambda .)
    |               reduce using rule 68 (expression -> lambda .)
    RANGER          reduce using rule 68 (expression -> lambda .)
    ]               reduce using rule 68 (expression -> lambda .)
    }               reduce using rule 68 (expression -> lambda .)
    :               reduce using rule 68 (expression -> lambda .)
    ELSE            reduce using rule 68 (expression -> lambda .)


state 67

    (69) expression -> cond_block .

    `               reduce using rule 69 (expression -> cond_block .)
    SPECIALID       reduce using rule 69 (expression -> cond_block .)
    END             reduce using rule 69 (expression -> cond_block .)
    ALIAS           reduce using rule 69 (expression -> cond_block .)
    LET             reduce using rule 69 (expression -> cond_block .)
    FDEF            reduce using rule 69 (expression -> cond_block .)
    THEN            reduce using rule 69 (expression -> cond_block .)
    )               reduce using rule 69 (expression -> cond_block .)
    ,               reduce using rule 69 (expression -> cond_block .)
    |               reduce using rule 69 (expression -> cond_block .)
    RANGER          reduce using rule 69 (expression -> cond_block .)
    ]               reduce using rule 69 (expression -> cond_block .)
    }               reduce using rule 69 (expression -> cond_block .)
    :               reduce using rule 69 (expression -> cond_block .)
    ELSE            reduce using rule 69 (expression -> cond_block .)


state 68

    (76) multivar -> primaryvar .

    (               reduce using rule 76 (multivar -> primaryvar .)
    `               reduce using rule 76 (multivar -> primaryvar .)
    SPECIALID       reduce using rule 76 (multivar -> primaryvar .)
    END             reduce using rule 76 (multivar -> primaryvar .)
    ALIAS           reduce using rule 76 (multivar -> primaryvar .)
    LET             reduce using rule 76 (multivar -> primaryvar .)
    FDEF            reduce using rule 76 (multivar -> primaryvar .)
    THEN            reduce using rule 76 (multivar -> primaryvar .)
    )               reduce using rule 76 (multivar -> primaryvar .)
    ,               reduce using rule 76 (multivar -> primaryvar .)
    |               reduce using rule 76 (multivar -> primaryvar .)
    RANGER          reduce using rule 76 (multivar -> primaryvar .)
    ]               reduce using rule 76 (multivar -> primaryvar .)
    }               reduce using rule 76 (multivar -> primaryvar .)
    :               reduce using rule 76 (multivar -> primaryvar .)
    ELSE            reduce using rule 76 (multivar -> primaryvar .)


state 69

    (77) multivar -> rlist .

    (               reduce using rule 77 (multivar -> rlist .)
    `               reduce using rule 77 (multivar -> rlist .)
    SPECIALID       reduce using rule 77 (multivar -> rlist .)
    END             reduce using rule 77 (multivar -> rlist .)
    ALIAS           reduce using rule 77 (multivar -> rlist .)
    LET             reduce using rule 77 (multivar -> rlist .)
    FDEF            reduce using rule 77 (multivar -> rlist .)
    THEN            reduce using rule 77 (multivar -> rlist .)
    )               reduce using rule 77 (multivar -> rlist .)
    ,               reduce using rule 77 (multivar -> rlist .)
    |               reduce using rule 77 (multivar -> rlist .)
    RANGER          reduce using rule 77 (multivar -> rlist .)
    ]               reduce using rule 77 (multivar -> rlist .)
    }               reduce using rule 77 (multivar -> rlist .)
    :               reduce using rule 77 (multivar -> rlist .)
    ELSE            reduce using rule 77 (multivar -> rlist .)


state 70

    (78) multivar -> rtuple .

    (               reduce using rule 78 (multivar -> rtuple .)
    `               reduce using rule 78 (multivar -> rtuple .)
    SPECIALID       reduce using rule 78 (multivar -> rtuple .)
    END             reduce using rule 78 (multivar -> rtuple .)
    ALIAS           reduce using rule 78 (multivar -> rtuple .)
    LET             reduce using rule 78 (multivar -> rtuple .)
    FDEF            reduce using rule 78 (multivar -> rtuple .)
    THEN            reduce using rule 78 (multivar -> rtuple .)
    )               reduce using rule 78 (multivar -> rtuple .)
    ,               reduce using rule 78 (multivar -> rtuple .)
    |               reduce using rule 78 (multivar -> rtuple .)
    RANGER          reduce using rule 78 (multivar -> rtuple .)
    ]               reduce using rule 78 (multivar -> rtuple .)
    }               reduce using rule 78 (multivar -> rtuple .)
    :               reduce using rule 78 (multivar -> rtuple .)
    ELSE            reduce using rule 78 (multivar -> rtuple .)


state 71

    (74) lambda -> FDEF . ( ) { conditional }
    (75) lambda -> FDEF . ( pattern_list ) { conditional }

    (               shift and go to state 106


state 72

    (70) cond_block -> COND . { cond , ELSE : conditional }

    {               shift and go to state 107


state 73

    (81) primaryvar -> [ . SPECIALID ]
    (92) rlist -> [ . ]
    (93) rlist -> [ . condition_list ]
    (94) rlist -> [ . conditional | conditional ]
    (95) rlist -> [ . conditional RANGER conditional ]
    (96) condition_list -> . conditional
    (97) condition_list -> . condition_list , conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    SPECIALID       shift and go to state 108
    ]               shift and go to state 109
    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    condition_list                 shift and go to state 110
    conditional                    shift and go to state 111
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 74

    (82) primaryvar -> INTT .

    (               reduce using rule 82 (primaryvar -> INTT .)
    `               reduce using rule 82 (primaryvar -> INTT .)
    SPECIALID       reduce using rule 82 (primaryvar -> INTT .)
    END             reduce using rule 82 (primaryvar -> INTT .)
    ALIAS           reduce using rule 82 (primaryvar -> INTT .)
    LET             reduce using rule 82 (primaryvar -> INTT .)
    FDEF            reduce using rule 82 (primaryvar -> INTT .)
    THEN            reduce using rule 82 (primaryvar -> INTT .)
    )               reduce using rule 82 (primaryvar -> INTT .)
    ,               reduce using rule 82 (primaryvar -> INTT .)
    |               reduce using rule 82 (primaryvar -> INTT .)
    RANGER          reduce using rule 82 (primaryvar -> INTT .)
    ]               reduce using rule 82 (primaryvar -> INTT .)
    }               reduce using rule 82 (primaryvar -> INTT .)
    :               reduce using rule 82 (primaryvar -> INTT .)
    ELSE            reduce using rule 82 (primaryvar -> INTT .)


state 75

    (83) primaryvar -> FLOATT .

    (               reduce using rule 83 (primaryvar -> FLOATT .)
    `               reduce using rule 83 (primaryvar -> FLOATT .)
    SPECIALID       reduce using rule 83 (primaryvar -> FLOATT .)
    END             reduce using rule 83 (primaryvar -> FLOATT .)
    ALIAS           reduce using rule 83 (primaryvar -> FLOATT .)
    LET             reduce using rule 83 (primaryvar -> FLOATT .)
    FDEF            reduce using rule 83 (primaryvar -> FLOATT .)
    THEN            reduce using rule 83 (primaryvar -> FLOATT .)
    )               reduce using rule 83 (primaryvar -> FLOATT .)
    ,               reduce using rule 83 (primaryvar -> FLOATT .)
    |               reduce using rule 83 (primaryvar -> FLOATT .)
    RANGER          reduce using rule 83 (primaryvar -> FLOATT .)
    ]               reduce using rule 83 (primaryvar -> FLOATT .)
    }               reduce using rule 83 (primaryvar -> FLOATT .)
    :               reduce using rule 83 (primaryvar -> FLOATT .)
    ELSE            reduce using rule 83 (primaryvar -> FLOATT .)


state 76

    (84) primaryvar -> CHART .

    (               reduce using rule 84 (primaryvar -> CHART .)
    `               reduce using rule 84 (primaryvar -> CHART .)
    SPECIALID       reduce using rule 84 (primaryvar -> CHART .)
    END             reduce using rule 84 (primaryvar -> CHART .)
    ALIAS           reduce using rule 84 (primaryvar -> CHART .)
    LET             reduce using rule 84 (primaryvar -> CHART .)
    FDEF            reduce using rule 84 (primaryvar -> CHART .)
    THEN            reduce using rule 84 (primaryvar -> CHART .)
    )               reduce using rule 84 (primaryvar -> CHART .)
    ,               reduce using rule 84 (primaryvar -> CHART .)
    |               reduce using rule 84 (primaryvar -> CHART .)
    RANGER          reduce using rule 84 (primaryvar -> CHART .)
    ]               reduce using rule 84 (primaryvar -> CHART .)
    }               reduce using rule 84 (primaryvar -> CHART .)
    :               reduce using rule 84 (primaryvar -> CHART .)
    ELSE            reduce using rule 84 (primaryvar -> CHART .)


state 77

    (85) primaryvar -> STRINGT .

    (               reduce using rule 85 (primaryvar -> STRINGT .)
    `               reduce using rule 85 (primaryvar -> STRINGT .)
    SPECIALID       reduce using rule 85 (primaryvar -> STRINGT .)
    END             reduce using rule 85 (primaryvar -> STRINGT .)
    ALIAS           reduce using rule 85 (primaryvar -> STRINGT .)
    LET             reduce using rule 85 (primaryvar -> STRINGT .)
    FDEF            reduce using rule 85 (primaryvar -> STRINGT .)
    THEN            reduce using rule 85 (primaryvar -> STRINGT .)
    )               reduce using rule 85 (primaryvar -> STRINGT .)
    ,               reduce using rule 85 (primaryvar -> STRINGT .)
    |               reduce using rule 85 (primaryvar -> STRINGT .)
    RANGER          reduce using rule 85 (primaryvar -> STRINGT .)
    ]               reduce using rule 85 (primaryvar -> STRINGT .)
    }               reduce using rule 85 (primaryvar -> STRINGT .)
    :               reduce using rule 85 (primaryvar -> STRINGT .)
    ELSE            reduce using rule 85 (primaryvar -> STRINGT .)


state 78

    (86) primaryvar -> BOOLT .

    (               reduce using rule 86 (primaryvar -> BOOLT .)
    `               reduce using rule 86 (primaryvar -> BOOLT .)
    SPECIALID       reduce using rule 86 (primaryvar -> BOOLT .)
    END             reduce using rule 86 (primaryvar -> BOOLT .)
    ALIAS           reduce using rule 86 (primaryvar -> BOOLT .)
    LET             reduce using rule 86 (primaryvar -> BOOLT .)
    FDEF            reduce using rule 86 (primaryvar -> BOOLT .)
    THEN            reduce using rule 86 (primaryvar -> BOOLT .)
    )               reduce using rule 86 (primaryvar -> BOOLT .)
    ,               reduce using rule 86 (primaryvar -> BOOLT .)
    |               reduce using rule 86 (primaryvar -> BOOLT .)
    RANGER          reduce using rule 86 (primaryvar -> BOOLT .)
    ]               reduce using rule 86 (primaryvar -> BOOLT .)
    }               reduce using rule 86 (primaryvar -> BOOLT .)
    :               reduce using rule 86 (primaryvar -> BOOLT .)
    ELSE            reduce using rule 86 (primaryvar -> BOOLT .)


state 79

    (9) function -> FDEF prefix args returntype { . compound }
    (10) function -> FDEF prefix args returntype { . let_block compound }
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (36) let_block -> . LET { let_cont }
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    (               shift and go to state 64
    LET             shift and go to state 114
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    compound                       shift and go to state 112
    let_block                      shift and go to state 113
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 80

    (18) returntype -> RARROW typedesc .

    {               reduce using rule 18 (returntype -> RARROW typedesc .)


state 81

    (48) ltuple -> ( ) .

    :               reduce using rule 48 (ltuple -> ( ) .)
    )               reduce using rule 48 (ltuple -> ( ) .)
    ,               reduce using rule 48 (ltuple -> ( ) .)
    |               reduce using rule 48 (ltuple -> ( ) .)
    ]               reduce using rule 48 (ltuple -> ( ) .)
    =               reduce using rule 48 (ltuple -> ( ) .)


state 82

    (49) ltuple -> ( ltuple_cont . )
    (51) ltuple_cont -> ltuple_cont . , lpattern

    )               shift and go to state 115
    ,               shift and go to state 116


state 83

    (50) ltuple_cont -> lpattern . , lpattern

    ,               shift and go to state 117


state 84

    (12) args -> ( arg_list ) .

    RARROW          reduce using rule 12 (args -> ( arg_list ) .)
    {               reduce using rule 12 (args -> ( arg_list ) .)


state 85

    (14) arg_list -> arg_list , . lpattern annotation
    (40) lpattern -> . lvar
    (41) lpattern -> . llist
    (42) lpattern -> . ltuple
    (52) lvar -> . ID
    (53) lvar -> . [ SPECIALID ]
    (54) lvar -> . STRINGT
    (55) lvar -> . INTT
    (56) lvar -> . FLOATT
    (57) lvar -> . CHART
    (58) lvar -> . BOOLT
    (43) llist -> . [ ]
    (44) llist -> . [ pattern_list ]
    (45) llist -> . [ lpattern | lpattern ]
    (48) ltuple -> . ( )
    (49) ltuple -> . ( ltuple_cont )

    ID              shift and go to state 46
    [               shift and go to state 47
    STRINGT         shift and go to state 48
    INTT            shift and go to state 49
    FLOATT          shift and go to state 50
    CHART           shift and go to state 51
    BOOLT           shift and go to state 52
    (               shift and go to state 39

    lpattern                       shift and go to state 118
    lvar                           shift and go to state 43
    llist                          shift and go to state 44
    ltuple                         shift and go to state 45

state 86

    (13) arg_list -> lpattern annotation .

    )               reduce using rule 13 (arg_list -> lpattern annotation .)
    ,               reduce using rule 13 (arg_list -> lpattern annotation .)


state 87

    (53) lvar -> [ SPECIALID . ]

    ]               shift and go to state 119


state 88

    (43) llist -> [ ] .

    :               reduce using rule 43 (llist -> [ ] .)
    )               reduce using rule 43 (llist -> [ ] .)
    ,               reduce using rule 43 (llist -> [ ] .)
    |               reduce using rule 43 (llist -> [ ] .)
    ]               reduce using rule 43 (llist -> [ ] .)
    =               reduce using rule 43 (llist -> [ ] .)


state 89

    (44) llist -> [ pattern_list . ]
    (47) pattern_list -> pattern_list . , lpattern

    ]               shift and go to state 120
    ,               shift and go to state 121


state 90

    (45) llist -> [ lpattern . | lpattern ]
    (46) pattern_list -> lpattern .

    |               shift and go to state 122
    ]               reduce using rule 46 (pattern_list -> lpattern .)
    ,               reduce using rule 46 (pattern_list -> lpattern .)


state 91

    (24) typedesc -> ( tuple_type ) .
    (27) function_type -> ( tuple_type ) . RARROW typedesc

    END             reduce using rule 24 (typedesc -> ( tuple_type ) .)
    ALIAS           reduce using rule 24 (typedesc -> ( tuple_type ) .)
    LET             reduce using rule 24 (typedesc -> ( tuple_type ) .)
    FDEF            reduce using rule 24 (typedesc -> ( tuple_type ) .)
    =               reduce using rule 24 (typedesc -> ( tuple_type ) .)
    )               reduce using rule 24 (typedesc -> ( tuple_type ) .)
    ,               reduce using rule 24 (typedesc -> ( tuple_type ) .)
    ]               reduce using rule 24 (typedesc -> ( tuple_type ) .)
    {               reduce using rule 24 (typedesc -> ( tuple_type ) .)
    RARROW          shift and go to state 123


state 92

    (29) tuple_type -> tuple_type , . typeid
    (30) typeid -> . INT
    (31) typeid -> . FLOAT
    (32) typeid -> . CHAR
    (33) typeid -> . BOOL
    (34) typeid -> . ID
    (35) typeid -> . [ typedesc ]

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31
    BOOL            shift and go to state 32
    ID              shift and go to state 23
    [               shift and go to state 33

    typeid                         shift and go to state 124

state 93

    (26) function_type -> ( typedesc ) . RARROW typedesc

    RARROW          shift and go to state 125


state 94

    (28) tuple_type -> typeid , . typeid
    (30) typeid -> . INT
    (31) typeid -> . FLOAT
    (32) typeid -> . CHAR
    (33) typeid -> . BOOL
    (34) typeid -> . ID
    (35) typeid -> . [ typedesc ]

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31
    BOOL            shift and go to state 32
    ID              shift and go to state 23
    [               shift and go to state 33

    typeid                         shift and go to state 126

state 95

    (35) typeid -> [ typedesc ] .

    END             reduce using rule 35 (typeid -> [ typedesc ] .)
    ALIAS           reduce using rule 35 (typeid -> [ typedesc ] .)
    LET             reduce using rule 35 (typeid -> [ typedesc ] .)
    FDEF            reduce using rule 35 (typeid -> [ typedesc ] .)
    =               reduce using rule 35 (typeid -> [ typedesc ] .)
    )               reduce using rule 35 (typeid -> [ typedesc ] .)
    ,               reduce using rule 35 (typeid -> [ typedesc ] .)
    ]               reduce using rule 35 (typeid -> [ typedesc ] .)
    {               reduce using rule 35 (typeid -> [ typedesc ] .)


state 96

    (62) compound -> compound infix . expression
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78
    (               shift and go to state 128

    expression                     shift and go to state 127
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 97

    (65) infix -> ` . ID `

    ID              shift and go to state 129


state 98

    (66) infix -> SPECIALID .

    FDEF            reduce using rule 66 (infix -> SPECIALID .)
    COND            reduce using rule 66 (infix -> SPECIALID .)
    ID              reduce using rule 66 (infix -> SPECIALID .)
    [               reduce using rule 66 (infix -> SPECIALID .)
    INTT            reduce using rule 66 (infix -> SPECIALID .)
    FLOATT          reduce using rule 66 (infix -> SPECIALID .)
    CHART           reduce using rule 66 (infix -> SPECIALID .)
    STRINGT         reduce using rule 66 (infix -> SPECIALID .)
    BOOLT           reduce using rule 66 (infix -> SPECIALID .)
    (               reduce using rule 66 (infix -> SPECIALID .)
    )               reduce using rule 66 (infix -> SPECIALID .)


state 99

    (60) conditional -> IF conditional . THEN conditional ELSE conditional

    THEN            shift and go to state 130


state 100

    (63) compound -> ( compound . infix )
    (62) compound -> compound . infix expression
    (59) conditional -> compound .
    (65) infix -> . ` ID `
    (66) infix -> . SPECIALID

    )               reduce using rule 59 (conditional -> compound .)
    ,               reduce using rule 59 (conditional -> compound .)
    `               shift and go to state 97
    SPECIALID       shift and go to state 98

    infix                          shift and go to state 131

state 101

    (64) compound -> ( infix . expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78
    (               shift and go to state 128

    expression                     shift and go to state 132
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 102

    (88) rtuple -> ( ) .

    (               reduce using rule 88 (rtuple -> ( ) .)
    `               reduce using rule 88 (rtuple -> ( ) .)
    SPECIALID       reduce using rule 88 (rtuple -> ( ) .)
    END             reduce using rule 88 (rtuple -> ( ) .)
    ALIAS           reduce using rule 88 (rtuple -> ( ) .)
    LET             reduce using rule 88 (rtuple -> ( ) .)
    FDEF            reduce using rule 88 (rtuple -> ( ) .)
    THEN            reduce using rule 88 (rtuple -> ( ) .)
    )               reduce using rule 88 (rtuple -> ( ) .)
    ,               reduce using rule 88 (rtuple -> ( ) .)
    |               reduce using rule 88 (rtuple -> ( ) .)
    RANGER          reduce using rule 88 (rtuple -> ( ) .)
    ]               reduce using rule 88 (rtuple -> ( ) .)
    }               reduce using rule 88 (rtuple -> ( ) .)
    :               reduce using rule 88 (rtuple -> ( ) .)
    ELSE            reduce using rule 88 (rtuple -> ( ) .)


state 103

    (87) primaryvar -> ( conditional . )
    (90) rtuple_cont -> conditional . , conditional

    )               shift and go to state 133
    ,               shift and go to state 134


state 104

    (89) rtuple -> ( rtuple_cont . )
    (91) rtuple_cont -> rtuple_cont . , conditional

    )               shift and go to state 135
    ,               shift and go to state 136


state 105

    (79) multivar -> multivar ( . condition_list )
    (96) condition_list -> . conditional
    (97) condition_list -> . condition_list , conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    multivar                       shift and go to state 65
    condition_list                 shift and go to state 137
    conditional                    shift and go to state 138
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 106

    (74) lambda -> FDEF ( . ) { conditional }
    (75) lambda -> FDEF ( . pattern_list ) { conditional }
    (46) pattern_list -> . lpattern
    (47) pattern_list -> . pattern_list , lpattern
    (40) lpattern -> . lvar
    (41) lpattern -> . llist
    (42) lpattern -> . ltuple
    (52) lvar -> . ID
    (53) lvar -> . [ SPECIALID ]
    (54) lvar -> . STRINGT
    (55) lvar -> . INTT
    (56) lvar -> . FLOATT
    (57) lvar -> . CHART
    (58) lvar -> . BOOLT
    (43) llist -> . [ ]
    (44) llist -> . [ pattern_list ]
    (45) llist -> . [ lpattern | lpattern ]
    (48) ltuple -> . ( )
    (49) ltuple -> . ( ltuple_cont )

    )               shift and go to state 139
    ID              shift and go to state 46
    [               shift and go to state 47
    STRINGT         shift and go to state 48
    INTT            shift and go to state 49
    FLOATT          shift and go to state 50
    CHART           shift and go to state 51
    BOOLT           shift and go to state 52
    (               shift and go to state 39

    pattern_list                   shift and go to state 140
    lpattern                       shift and go to state 141
    lvar                           shift and go to state 43
    llist                          shift and go to state 44
    ltuple                         shift and go to state 45

state 107

    (70) cond_block -> COND { . cond , ELSE : conditional }
    (71) cond -> . cond_singl
    (72) cond -> . cond , cond_singl
    (73) cond_singl -> . conditional : conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    cond                           shift and go to state 142
    conditional                    shift and go to state 143
    cond_singl                     shift and go to state 144
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 108

    (81) primaryvar -> [ SPECIALID . ]

    ]               shift and go to state 145


state 109

    (92) rlist -> [ ] .

    (               reduce using rule 92 (rlist -> [ ] .)
    `               reduce using rule 92 (rlist -> [ ] .)
    SPECIALID       reduce using rule 92 (rlist -> [ ] .)
    END             reduce using rule 92 (rlist -> [ ] .)
    ALIAS           reduce using rule 92 (rlist -> [ ] .)
    LET             reduce using rule 92 (rlist -> [ ] .)
    FDEF            reduce using rule 92 (rlist -> [ ] .)
    THEN            reduce using rule 92 (rlist -> [ ] .)
    )               reduce using rule 92 (rlist -> [ ] .)
    ,               reduce using rule 92 (rlist -> [ ] .)
    |               reduce using rule 92 (rlist -> [ ] .)
    RANGER          reduce using rule 92 (rlist -> [ ] .)
    ]               reduce using rule 92 (rlist -> [ ] .)
    }               reduce using rule 92 (rlist -> [ ] .)
    :               reduce using rule 92 (rlist -> [ ] .)
    ELSE            reduce using rule 92 (rlist -> [ ] .)


state 110

    (93) rlist -> [ condition_list . ]
    (97) condition_list -> condition_list . , conditional

    ]               shift and go to state 146
    ,               shift and go to state 147


state 111

    (94) rlist -> [ conditional . | conditional ]
    (95) rlist -> [ conditional . RANGER conditional ]
    (96) condition_list -> conditional .

    |               shift and go to state 148
    RANGER          shift and go to state 149
    ]               reduce using rule 96 (condition_list -> conditional .)
    ,               reduce using rule 96 (condition_list -> conditional .)


state 112

    (9) function -> FDEF prefix args returntype { compound . }
    (62) compound -> compound . infix expression
    (65) infix -> . ` ID `
    (66) infix -> . SPECIALID

    }               shift and go to state 150
    `               shift and go to state 97
    SPECIALID       shift and go to state 98

    infix                          shift and go to state 96

state 113

    (10) function -> FDEF prefix args returntype { let_block . compound }
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    compound                       shift and go to state 151
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 114

    (36) let_block -> LET . { let_cont }

    {               shift and go to state 152


state 115

    (49) ltuple -> ( ltuple_cont ) .

    :               reduce using rule 49 (ltuple -> ( ltuple_cont ) .)
    )               reduce using rule 49 (ltuple -> ( ltuple_cont ) .)
    ,               reduce using rule 49 (ltuple -> ( ltuple_cont ) .)
    |               reduce using rule 49 (ltuple -> ( ltuple_cont ) .)
    ]               reduce using rule 49 (ltuple -> ( ltuple_cont ) .)
    =               reduce using rule 49 (ltuple -> ( ltuple_cont ) .)


state 116

    (51) ltuple_cont -> ltuple_cont , . lpattern
    (40) lpattern -> . lvar
    (41) lpattern -> . llist
    (42) lpattern -> . ltuple
    (52) lvar -> . ID
    (53) lvar -> . [ SPECIALID ]
    (54) lvar -> . STRINGT
    (55) lvar -> . INTT
    (56) lvar -> . FLOATT
    (57) lvar -> . CHART
    (58) lvar -> . BOOLT
    (43) llist -> . [ ]
    (44) llist -> . [ pattern_list ]
    (45) llist -> . [ lpattern | lpattern ]
    (48) ltuple -> . ( )
    (49) ltuple -> . ( ltuple_cont )

    ID              shift and go to state 46
    [               shift and go to state 47
    STRINGT         shift and go to state 48
    INTT            shift and go to state 49
    FLOATT          shift and go to state 50
    CHART           shift and go to state 51
    BOOLT           shift and go to state 52
    (               shift and go to state 39

    lpattern                       shift and go to state 153
    lvar                           shift and go to state 43
    llist                          shift and go to state 44
    ltuple                         shift and go to state 45

state 117

    (50) ltuple_cont -> lpattern , . lpattern
    (40) lpattern -> . lvar
    (41) lpattern -> . llist
    (42) lpattern -> . ltuple
    (52) lvar -> . ID
    (53) lvar -> . [ SPECIALID ]
    (54) lvar -> . STRINGT
    (55) lvar -> . INTT
    (56) lvar -> . FLOATT
    (57) lvar -> . CHART
    (58) lvar -> . BOOLT
    (43) llist -> . [ ]
    (44) llist -> . [ pattern_list ]
    (45) llist -> . [ lpattern | lpattern ]
    (48) ltuple -> . ( )
    (49) ltuple -> . ( ltuple_cont )

    ID              shift and go to state 46
    [               shift and go to state 47
    STRINGT         shift and go to state 48
    INTT            shift and go to state 49
    FLOATT          shift and go to state 50
    CHART           shift and go to state 51
    BOOLT           shift and go to state 52
    (               shift and go to state 39

    lpattern                       shift and go to state 154
    lvar                           shift and go to state 43
    llist                          shift and go to state 44
    ltuple                         shift and go to state 45

state 118

    (14) arg_list -> arg_list , lpattern . annotation
    (19) annotation -> .
    (20) annotation -> . : typedesc

    )               reduce using rule 19 (annotation -> .)
    ,               reduce using rule 19 (annotation -> .)
    :               shift and go to state 19

    annotation                     shift and go to state 155

state 119

    (53) lvar -> [ SPECIALID ] .

    :               reduce using rule 53 (lvar -> [ SPECIALID ] .)
    )               reduce using rule 53 (lvar -> [ SPECIALID ] .)
    ,               reduce using rule 53 (lvar -> [ SPECIALID ] .)
    |               reduce using rule 53 (lvar -> [ SPECIALID ] .)
    ]               reduce using rule 53 (lvar -> [ SPECIALID ] .)
    =               reduce using rule 53 (lvar -> [ SPECIALID ] .)


state 120

    (44) llist -> [ pattern_list ] .

    :               reduce using rule 44 (llist -> [ pattern_list ] .)
    )               reduce using rule 44 (llist -> [ pattern_list ] .)
    ,               reduce using rule 44 (llist -> [ pattern_list ] .)
    |               reduce using rule 44 (llist -> [ pattern_list ] .)
    ]               reduce using rule 44 (llist -> [ pattern_list ] .)
    =               reduce using rule 44 (llist -> [ pattern_list ] .)


state 121

    (47) pattern_list -> pattern_list , . lpattern
    (40) lpattern -> . lvar
    (41) lpattern -> . llist
    (42) lpattern -> . ltuple
    (52) lvar -> . ID
    (53) lvar -> . [ SPECIALID ]
    (54) lvar -> . STRINGT
    (55) lvar -> . INTT
    (56) lvar -> . FLOATT
    (57) lvar -> . CHART
    (58) lvar -> . BOOLT
    (43) llist -> . [ ]
    (44) llist -> . [ pattern_list ]
    (45) llist -> . [ lpattern | lpattern ]
    (48) ltuple -> . ( )
    (49) ltuple -> . ( ltuple_cont )

    ID              shift and go to state 46
    [               shift and go to state 47
    STRINGT         shift and go to state 48
    INTT            shift and go to state 49
    FLOATT          shift and go to state 50
    CHART           shift and go to state 51
    BOOLT           shift and go to state 52
    (               shift and go to state 39

    lpattern                       shift and go to state 156
    lvar                           shift and go to state 43
    llist                          shift and go to state 44
    ltuple                         shift and go to state 45

state 122

    (45) llist -> [ lpattern | . lpattern ]
    (40) lpattern -> . lvar
    (41) lpattern -> . llist
    (42) lpattern -> . ltuple
    (52) lvar -> . ID
    (53) lvar -> . [ SPECIALID ]
    (54) lvar -> . STRINGT
    (55) lvar -> . INTT
    (56) lvar -> . FLOATT
    (57) lvar -> . CHART
    (58) lvar -> . BOOLT
    (43) llist -> . [ ]
    (44) llist -> . [ pattern_list ]
    (45) llist -> . [ lpattern | lpattern ]
    (48) ltuple -> . ( )
    (49) ltuple -> . ( ltuple_cont )

    ID              shift and go to state 46
    [               shift and go to state 47
    STRINGT         shift and go to state 48
    INTT            shift and go to state 49
    FLOATT          shift and go to state 50
    CHART           shift and go to state 51
    BOOLT           shift and go to state 52
    (               shift and go to state 39

    lpattern                       shift and go to state 157
    lvar                           shift and go to state 43
    llist                          shift and go to state 44
    ltuple                         shift and go to state 45

state 123

    (27) function_type -> ( tuple_type ) RARROW . typedesc
    (21) typedesc -> . typeid
    (22) typedesc -> . typeclass
    (23) typedesc -> . function_type
    (24) typedesc -> . ( tuple_type )
    (30) typeid -> . INT
    (31) typeid -> . FLOAT
    (32) typeid -> . CHAR
    (33) typeid -> . BOOL
    (34) typeid -> . ID
    (35) typeid -> . [ typedesc ]
    (25) typeclass -> . TYPECLASS ID
    (26) function_type -> . ( typedesc ) RARROW typedesc
    (27) function_type -> . ( tuple_type ) RARROW typedesc

    (               shift and go to state 28
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31
    BOOL            shift and go to state 32
    ID              shift and go to state 23
    [               shift and go to state 33
    TYPECLASS       shift and go to state 34

    typedesc                       shift and go to state 158
    typeid                         shift and go to state 25
    typeclass                      shift and go to state 26
    function_type                  shift and go to state 27

state 124

    (29) tuple_type -> tuple_type , typeid .

    )               reduce using rule 29 (tuple_type -> tuple_type , typeid .)
    ,               reduce using rule 29 (tuple_type -> tuple_type , typeid .)


state 125

    (26) function_type -> ( typedesc ) RARROW . typedesc
    (21) typedesc -> . typeid
    (22) typedesc -> . typeclass
    (23) typedesc -> . function_type
    (24) typedesc -> . ( tuple_type )
    (30) typeid -> . INT
    (31) typeid -> . FLOAT
    (32) typeid -> . CHAR
    (33) typeid -> . BOOL
    (34) typeid -> . ID
    (35) typeid -> . [ typedesc ]
    (25) typeclass -> . TYPECLASS ID
    (26) function_type -> . ( typedesc ) RARROW typedesc
    (27) function_type -> . ( tuple_type ) RARROW typedesc

    (               shift and go to state 28
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    CHAR            shift and go to state 31
    BOOL            shift and go to state 32
    ID              shift and go to state 23
    [               shift and go to state 33
    TYPECLASS       shift and go to state 34

    typedesc                       shift and go to state 159
    typeid                         shift and go to state 25
    typeclass                      shift and go to state 26
    function_type                  shift and go to state 27

state 126

    (28) tuple_type -> typeid , typeid .

    )               reduce using rule 28 (tuple_type -> typeid , typeid .)
    ,               reduce using rule 28 (tuple_type -> typeid , typeid .)


state 127

    (62) compound -> compound infix expression .

    `               reduce using rule 62 (compound -> compound infix expression .)
    SPECIALID       reduce using rule 62 (compound -> compound infix expression .)
    END             reduce using rule 62 (compound -> compound infix expression .)
    ALIAS           reduce using rule 62 (compound -> compound infix expression .)
    LET             reduce using rule 62 (compound -> compound infix expression .)
    FDEF            reduce using rule 62 (compound -> compound infix expression .)
    THEN            reduce using rule 62 (compound -> compound infix expression .)
    )               reduce using rule 62 (compound -> compound infix expression .)
    ,               reduce using rule 62 (compound -> compound infix expression .)
    |               reduce using rule 62 (compound -> compound infix expression .)
    RANGER          reduce using rule 62 (compound -> compound infix expression .)
    ]               reduce using rule 62 (compound -> compound infix expression .)
    }               reduce using rule 62 (compound -> compound infix expression .)
    :               reduce using rule 62 (compound -> compound infix expression .)
    ELSE            reduce using rule 62 (compound -> compound infix expression .)


state 128

    (87) primaryvar -> ( . conditional )
    (88) rtuple -> ( . )
    (89) rtuple -> ( . rtuple_cont )
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (90) rtuple_cont -> . conditional , conditional
    (91) rtuple_cont -> . rtuple_cont , conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    )               shift and go to state 102
    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 103
    rtuple_cont                    shift and go to state 104
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 129

    (65) infix -> ` ID . `

    `               shift and go to state 160


state 130

    (60) conditional -> IF conditional THEN . conditional ELSE conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 161
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 131

    (63) compound -> ( compound infix . )
    (62) compound -> compound infix . expression
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    )               shift and go to state 162
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78
    (               shift and go to state 128

    expression                     shift and go to state 127
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 132

    (64) compound -> ( infix expression . )

    )               shift and go to state 163


state 133

    (87) primaryvar -> ( conditional ) .

    (               reduce using rule 87 (primaryvar -> ( conditional ) .)
    `               reduce using rule 87 (primaryvar -> ( conditional ) .)
    SPECIALID       reduce using rule 87 (primaryvar -> ( conditional ) .)
    END             reduce using rule 87 (primaryvar -> ( conditional ) .)
    ALIAS           reduce using rule 87 (primaryvar -> ( conditional ) .)
    LET             reduce using rule 87 (primaryvar -> ( conditional ) .)
    FDEF            reduce using rule 87 (primaryvar -> ( conditional ) .)
    THEN            reduce using rule 87 (primaryvar -> ( conditional ) .)
    )               reduce using rule 87 (primaryvar -> ( conditional ) .)
    ,               reduce using rule 87 (primaryvar -> ( conditional ) .)
    |               reduce using rule 87 (primaryvar -> ( conditional ) .)
    RANGER          reduce using rule 87 (primaryvar -> ( conditional ) .)
    ]               reduce using rule 87 (primaryvar -> ( conditional ) .)
    }               reduce using rule 87 (primaryvar -> ( conditional ) .)
    :               reduce using rule 87 (primaryvar -> ( conditional ) .)
    ELSE            reduce using rule 87 (primaryvar -> ( conditional ) .)


state 134

    (90) rtuple_cont -> conditional , . conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 164
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 135

    (89) rtuple -> ( rtuple_cont ) .

    (               reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    `               reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    SPECIALID       reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    END             reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    ALIAS           reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    LET             reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    FDEF            reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    THEN            reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    )               reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    ,               reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    |               reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    RANGER          reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    ]               reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    }               reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    :               reduce using rule 89 (rtuple -> ( rtuple_cont ) .)
    ELSE            reduce using rule 89 (rtuple -> ( rtuple_cont ) .)


state 136

    (91) rtuple_cont -> rtuple_cont , . conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 165
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 137

    (79) multivar -> multivar ( condition_list . )
    (97) condition_list -> condition_list . , conditional

    )               shift and go to state 166
    ,               shift and go to state 147


state 138

    (96) condition_list -> conditional .

    )               reduce using rule 96 (condition_list -> conditional .)
    ,               reduce using rule 96 (condition_list -> conditional .)


state 139

    (74) lambda -> FDEF ( ) . { conditional }

    {               shift and go to state 167


state 140

    (75) lambda -> FDEF ( pattern_list . ) { conditional }
    (47) pattern_list -> pattern_list . , lpattern

    )               shift and go to state 168
    ,               shift and go to state 121


state 141

    (46) pattern_list -> lpattern .

    )               reduce using rule 46 (pattern_list -> lpattern .)
    ,               reduce using rule 46 (pattern_list -> lpattern .)


state 142

    (70) cond_block -> COND { cond . , ELSE : conditional }
    (72) cond -> cond . , cond_singl

    ,               shift and go to state 169


state 143

    (73) cond_singl -> conditional . : conditional

    :               shift and go to state 170


state 144

    (71) cond -> cond_singl .

    ,               reduce using rule 71 (cond -> cond_singl .)


state 145

    (81) primaryvar -> [ SPECIALID ] .

    (               reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    `               reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    SPECIALID       reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    END             reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    ALIAS           reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    LET             reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    FDEF            reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    THEN            reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    )               reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    ,               reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    |               reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    RANGER          reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    ]               reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    }               reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    :               reduce using rule 81 (primaryvar -> [ SPECIALID ] .)
    ELSE            reduce using rule 81 (primaryvar -> [ SPECIALID ] .)


state 146

    (93) rlist -> [ condition_list ] .

    (               reduce using rule 93 (rlist -> [ condition_list ] .)
    `               reduce using rule 93 (rlist -> [ condition_list ] .)
    SPECIALID       reduce using rule 93 (rlist -> [ condition_list ] .)
    END             reduce using rule 93 (rlist -> [ condition_list ] .)
    ALIAS           reduce using rule 93 (rlist -> [ condition_list ] .)
    LET             reduce using rule 93 (rlist -> [ condition_list ] .)
    FDEF            reduce using rule 93 (rlist -> [ condition_list ] .)
    THEN            reduce using rule 93 (rlist -> [ condition_list ] .)
    )               reduce using rule 93 (rlist -> [ condition_list ] .)
    ,               reduce using rule 93 (rlist -> [ condition_list ] .)
    |               reduce using rule 93 (rlist -> [ condition_list ] .)
    RANGER          reduce using rule 93 (rlist -> [ condition_list ] .)
    ]               reduce using rule 93 (rlist -> [ condition_list ] .)
    }               reduce using rule 93 (rlist -> [ condition_list ] .)
    :               reduce using rule 93 (rlist -> [ condition_list ] .)
    ELSE            reduce using rule 93 (rlist -> [ condition_list ] .)


state 147

    (97) condition_list -> condition_list , . conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 171
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 148

    (94) rlist -> [ conditional | . conditional ]
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 172
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 149

    (95) rlist -> [ conditional RANGER . conditional ]
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 173
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 150

    (9) function -> FDEF prefix args returntype { compound } .

    END             reduce using rule 9 (function -> FDEF prefix args returntype { compound } .)
    ALIAS           reduce using rule 9 (function -> FDEF prefix args returntype { compound } .)
    LET             reduce using rule 9 (function -> FDEF prefix args returntype { compound } .)
    FDEF            reduce using rule 9 (function -> FDEF prefix args returntype { compound } .)


state 151

    (10) function -> FDEF prefix args returntype { let_block compound . }
    (62) compound -> compound . infix expression
    (65) infix -> . ` ID `
    (66) infix -> . SPECIALID

    }               shift and go to state 174
    `               shift and go to state 97
    SPECIALID       shift and go to state 98

    infix                          shift and go to state 96

state 152

    (36) let_block -> LET { . let_cont }
    (37) let_cont -> . assign
    (38) let_cont -> . let_cont , assign
    (39) assign -> . lpattern annotation = conditional
    (40) lpattern -> . lvar
    (41) lpattern -> . llist
    (42) lpattern -> . ltuple
    (52) lvar -> . ID
    (53) lvar -> . [ SPECIALID ]
    (54) lvar -> . STRINGT
    (55) lvar -> . INTT
    (56) lvar -> . FLOATT
    (57) lvar -> . CHART
    (58) lvar -> . BOOLT
    (43) llist -> . [ ]
    (44) llist -> . [ pattern_list ]
    (45) llist -> . [ lpattern | lpattern ]
    (48) ltuple -> . ( )
    (49) ltuple -> . ( ltuple_cont )

    ID              shift and go to state 46
    [               shift and go to state 47
    STRINGT         shift and go to state 48
    INTT            shift and go to state 49
    FLOATT          shift and go to state 50
    CHART           shift and go to state 51
    BOOLT           shift and go to state 52
    (               shift and go to state 39

    let_cont                       shift and go to state 175
    assign                         shift and go to state 176
    lpattern                       shift and go to state 177
    lvar                           shift and go to state 43
    llist                          shift and go to state 44
    ltuple                         shift and go to state 45

state 153

    (51) ltuple_cont -> ltuple_cont , lpattern .

    )               reduce using rule 51 (ltuple_cont -> ltuple_cont , lpattern .)
    ,               reduce using rule 51 (ltuple_cont -> ltuple_cont , lpattern .)


state 154

    (50) ltuple_cont -> lpattern , lpattern .

    )               reduce using rule 50 (ltuple_cont -> lpattern , lpattern .)
    ,               reduce using rule 50 (ltuple_cont -> lpattern , lpattern .)


state 155

    (14) arg_list -> arg_list , lpattern annotation .

    )               reduce using rule 14 (arg_list -> arg_list , lpattern annotation .)
    ,               reduce using rule 14 (arg_list -> arg_list , lpattern annotation .)


state 156

    (47) pattern_list -> pattern_list , lpattern .

    ]               reduce using rule 47 (pattern_list -> pattern_list , lpattern .)
    ,               reduce using rule 47 (pattern_list -> pattern_list , lpattern .)
    )               reduce using rule 47 (pattern_list -> pattern_list , lpattern .)


state 157

    (45) llist -> [ lpattern | lpattern . ]

    ]               shift and go to state 178


state 158

    (27) function_type -> ( tuple_type ) RARROW typedesc .

    END             reduce using rule 27 (function_type -> ( tuple_type ) RARROW typedesc .)
    ALIAS           reduce using rule 27 (function_type -> ( tuple_type ) RARROW typedesc .)
    LET             reduce using rule 27 (function_type -> ( tuple_type ) RARROW typedesc .)
    FDEF            reduce using rule 27 (function_type -> ( tuple_type ) RARROW typedesc .)
    =               reduce using rule 27 (function_type -> ( tuple_type ) RARROW typedesc .)
    )               reduce using rule 27 (function_type -> ( tuple_type ) RARROW typedesc .)
    ,               reduce using rule 27 (function_type -> ( tuple_type ) RARROW typedesc .)
    ]               reduce using rule 27 (function_type -> ( tuple_type ) RARROW typedesc .)
    {               reduce using rule 27 (function_type -> ( tuple_type ) RARROW typedesc .)


state 159

    (26) function_type -> ( typedesc ) RARROW typedesc .

    END             reduce using rule 26 (function_type -> ( typedesc ) RARROW typedesc .)
    ALIAS           reduce using rule 26 (function_type -> ( typedesc ) RARROW typedesc .)
    LET             reduce using rule 26 (function_type -> ( typedesc ) RARROW typedesc .)
    FDEF            reduce using rule 26 (function_type -> ( typedesc ) RARROW typedesc .)
    =               reduce using rule 26 (function_type -> ( typedesc ) RARROW typedesc .)
    )               reduce using rule 26 (function_type -> ( typedesc ) RARROW typedesc .)
    ,               reduce using rule 26 (function_type -> ( typedesc ) RARROW typedesc .)
    ]               reduce using rule 26 (function_type -> ( typedesc ) RARROW typedesc .)
    {               reduce using rule 26 (function_type -> ( typedesc ) RARROW typedesc .)


state 160

    (65) infix -> ` ID ` .

    FDEF            reduce using rule 65 (infix -> ` ID ` .)
    COND            reduce using rule 65 (infix -> ` ID ` .)
    ID              reduce using rule 65 (infix -> ` ID ` .)
    [               reduce using rule 65 (infix -> ` ID ` .)
    INTT            reduce using rule 65 (infix -> ` ID ` .)
    FLOATT          reduce using rule 65 (infix -> ` ID ` .)
    CHART           reduce using rule 65 (infix -> ` ID ` .)
    STRINGT         reduce using rule 65 (infix -> ` ID ` .)
    BOOLT           reduce using rule 65 (infix -> ` ID ` .)
    (               reduce using rule 65 (infix -> ` ID ` .)
    )               reduce using rule 65 (infix -> ` ID ` .)


state 161

    (60) conditional -> IF conditional THEN conditional . ELSE conditional

    ELSE            shift and go to state 179


state 162

    (63) compound -> ( compound infix ) .

    `               reduce using rule 63 (compound -> ( compound infix ) .)
    SPECIALID       reduce using rule 63 (compound -> ( compound infix ) .)
    END             reduce using rule 63 (compound -> ( compound infix ) .)
    ALIAS           reduce using rule 63 (compound -> ( compound infix ) .)
    LET             reduce using rule 63 (compound -> ( compound infix ) .)
    FDEF            reduce using rule 63 (compound -> ( compound infix ) .)
    THEN            reduce using rule 63 (compound -> ( compound infix ) .)
    )               reduce using rule 63 (compound -> ( compound infix ) .)
    ,               reduce using rule 63 (compound -> ( compound infix ) .)
    |               reduce using rule 63 (compound -> ( compound infix ) .)
    RANGER          reduce using rule 63 (compound -> ( compound infix ) .)
    ]               reduce using rule 63 (compound -> ( compound infix ) .)
    }               reduce using rule 63 (compound -> ( compound infix ) .)
    :               reduce using rule 63 (compound -> ( compound infix ) .)
    ELSE            reduce using rule 63 (compound -> ( compound infix ) .)


state 163

    (64) compound -> ( infix expression ) .

    `               reduce using rule 64 (compound -> ( infix expression ) .)
    SPECIALID       reduce using rule 64 (compound -> ( infix expression ) .)
    END             reduce using rule 64 (compound -> ( infix expression ) .)
    ALIAS           reduce using rule 64 (compound -> ( infix expression ) .)
    LET             reduce using rule 64 (compound -> ( infix expression ) .)
    FDEF            reduce using rule 64 (compound -> ( infix expression ) .)
    THEN            reduce using rule 64 (compound -> ( infix expression ) .)
    )               reduce using rule 64 (compound -> ( infix expression ) .)
    ,               reduce using rule 64 (compound -> ( infix expression ) .)
    |               reduce using rule 64 (compound -> ( infix expression ) .)
    RANGER          reduce using rule 64 (compound -> ( infix expression ) .)
    ]               reduce using rule 64 (compound -> ( infix expression ) .)
    }               reduce using rule 64 (compound -> ( infix expression ) .)
    :               reduce using rule 64 (compound -> ( infix expression ) .)
    ELSE            reduce using rule 64 (compound -> ( infix expression ) .)


state 164

    (90) rtuple_cont -> conditional , conditional .

    )               reduce using rule 90 (rtuple_cont -> conditional , conditional .)
    ,               reduce using rule 90 (rtuple_cont -> conditional , conditional .)


state 165

    (91) rtuple_cont -> rtuple_cont , conditional .

    )               reduce using rule 91 (rtuple_cont -> rtuple_cont , conditional .)
    ,               reduce using rule 91 (rtuple_cont -> rtuple_cont , conditional .)


state 166

    (79) multivar -> multivar ( condition_list ) .

    (               reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    `               reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    SPECIALID       reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    END             reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    ALIAS           reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    LET             reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    FDEF            reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    THEN            reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    )               reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    ,               reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    |               reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    RANGER          reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    ]               reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    }               reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    :               reduce using rule 79 (multivar -> multivar ( condition_list ) .)
    ELSE            reduce using rule 79 (multivar -> multivar ( condition_list ) .)


state 167

    (74) lambda -> FDEF ( ) { . conditional }
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 180
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 168

    (75) lambda -> FDEF ( pattern_list ) . { conditional }

    {               shift and go to state 181


state 169

    (70) cond_block -> COND { cond , . ELSE : conditional }
    (72) cond -> cond , . cond_singl
    (73) cond_singl -> . conditional : conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    ELSE            shift and go to state 182
    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 143
    cond_singl                     shift and go to state 183
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 170

    (73) cond_singl -> conditional : . conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 184
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 171

    (97) condition_list -> condition_list , conditional .

    ]               reduce using rule 97 (condition_list -> condition_list , conditional .)
    ,               reduce using rule 97 (condition_list -> condition_list , conditional .)
    )               reduce using rule 97 (condition_list -> condition_list , conditional .)


state 172

    (94) rlist -> [ conditional | conditional . ]

    ]               shift and go to state 185


state 173

    (95) rlist -> [ conditional RANGER conditional . ]

    ]               shift and go to state 186


state 174

    (10) function -> FDEF prefix args returntype { let_block compound } .

    END             reduce using rule 10 (function -> FDEF prefix args returntype { let_block compound } .)
    ALIAS           reduce using rule 10 (function -> FDEF prefix args returntype { let_block compound } .)
    LET             reduce using rule 10 (function -> FDEF prefix args returntype { let_block compound } .)
    FDEF            reduce using rule 10 (function -> FDEF prefix args returntype { let_block compound } .)


state 175

    (36) let_block -> LET { let_cont . }
    (38) let_cont -> let_cont . , assign

    }               shift and go to state 187
    ,               shift and go to state 188


state 176

    (37) let_cont -> assign .

    }               reduce using rule 37 (let_cont -> assign .)
    ,               reduce using rule 37 (let_cont -> assign .)


state 177

    (39) assign -> lpattern . annotation = conditional
    (19) annotation -> .
    (20) annotation -> . : typedesc

    =               reduce using rule 19 (annotation -> .)
    :               shift and go to state 19

    annotation                     shift and go to state 189

state 178

    (45) llist -> [ lpattern | lpattern ] .

    :               reduce using rule 45 (llist -> [ lpattern | lpattern ] .)
    )               reduce using rule 45 (llist -> [ lpattern | lpattern ] .)
    ,               reduce using rule 45 (llist -> [ lpattern | lpattern ] .)
    |               reduce using rule 45 (llist -> [ lpattern | lpattern ] .)
    ]               reduce using rule 45 (llist -> [ lpattern | lpattern ] .)
    =               reduce using rule 45 (llist -> [ lpattern | lpattern ] .)


state 179

    (60) conditional -> IF conditional THEN conditional ELSE . conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 190
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 180

    (74) lambda -> FDEF ( ) { conditional . }

    }               shift and go to state 191


state 181

    (75) lambda -> FDEF ( pattern_list ) { . conditional }
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 192
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 182

    (70) cond_block -> COND { cond , ELSE . : conditional }

    :               shift and go to state 193


state 183

    (72) cond -> cond , cond_singl .

    ,               reduce using rule 72 (cond -> cond , cond_singl .)


state 184

    (73) cond_singl -> conditional : conditional .

    ,               reduce using rule 73 (cond_singl -> conditional : conditional .)


state 185

    (94) rlist -> [ conditional | conditional ] .

    (               reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    `               reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    SPECIALID       reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    END             reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    ALIAS           reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    LET             reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    FDEF            reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    THEN            reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    )               reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    ,               reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    |               reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    RANGER          reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    ]               reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    }               reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    :               reduce using rule 94 (rlist -> [ conditional | conditional ] .)
    ELSE            reduce using rule 94 (rlist -> [ conditional | conditional ] .)


state 186

    (95) rlist -> [ conditional RANGER conditional ] .

    (               reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    `               reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    SPECIALID       reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    END             reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    ALIAS           reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    LET             reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    FDEF            reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    THEN            reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    )               reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    ,               reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    |               reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    RANGER          reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    ]               reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    }               reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    :               reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)
    ELSE            reduce using rule 95 (rlist -> [ conditional RANGER conditional ] .)


state 187

    (36) let_block -> LET { let_cont } .

    (               reduce using rule 36 (let_block -> LET { let_cont } .)
    FDEF            reduce using rule 36 (let_block -> LET { let_cont } .)
    COND            reduce using rule 36 (let_block -> LET { let_cont } .)
    ID              reduce using rule 36 (let_block -> LET { let_cont } .)
    [               reduce using rule 36 (let_block -> LET { let_cont } .)
    INTT            reduce using rule 36 (let_block -> LET { let_cont } .)
    FLOATT          reduce using rule 36 (let_block -> LET { let_cont } .)
    CHART           reduce using rule 36 (let_block -> LET { let_cont } .)
    STRINGT         reduce using rule 36 (let_block -> LET { let_cont } .)
    BOOLT           reduce using rule 36 (let_block -> LET { let_cont } .)


state 188

    (38) let_cont -> let_cont , . assign
    (39) assign -> . lpattern annotation = conditional
    (40) lpattern -> . lvar
    (41) lpattern -> . llist
    (42) lpattern -> . ltuple
    (52) lvar -> . ID
    (53) lvar -> . [ SPECIALID ]
    (54) lvar -> . STRINGT
    (55) lvar -> . INTT
    (56) lvar -> . FLOATT
    (57) lvar -> . CHART
    (58) lvar -> . BOOLT
    (43) llist -> . [ ]
    (44) llist -> . [ pattern_list ]
    (45) llist -> . [ lpattern | lpattern ]
    (48) ltuple -> . ( )
    (49) ltuple -> . ( ltuple_cont )

    ID              shift and go to state 46
    [               shift and go to state 47
    STRINGT         shift and go to state 48
    INTT            shift and go to state 49
    FLOATT          shift and go to state 50
    CHART           shift and go to state 51
    BOOLT           shift and go to state 52
    (               shift and go to state 39

    assign                         shift and go to state 194
    lpattern                       shift and go to state 177
    lvar                           shift and go to state 43
    llist                          shift and go to state 44
    ltuple                         shift and go to state 45

state 189

    (39) assign -> lpattern annotation . = conditional

    =               shift and go to state 195


state 190

    (60) conditional -> IF conditional THEN conditional ELSE conditional .

    END             reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    ALIAS           reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    LET             reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    FDEF            reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    THEN            reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    )               reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    ,               reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    |               reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    RANGER          reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    ]               reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    :               reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    ELSE            reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)
    }               reduce using rule 60 (conditional -> IF conditional THEN conditional ELSE conditional .)


state 191

    (74) lambda -> FDEF ( ) { conditional } .

    `               reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    SPECIALID       reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    END             reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    ALIAS           reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    LET             reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    FDEF            reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    THEN            reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    )               reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    ,               reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    |               reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    RANGER          reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    ]               reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    }               reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    :               reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)
    ELSE            reduce using rule 74 (lambda -> FDEF ( ) { conditional } .)


state 192

    (75) lambda -> FDEF ( pattern_list ) { conditional . }

    }               shift and go to state 196


state 193

    (70) cond_block -> COND { cond , ELSE : . conditional }
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 197
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 194

    (38) let_cont -> let_cont , assign .

    }               reduce using rule 38 (let_cont -> let_cont , assign .)
    ,               reduce using rule 38 (let_cont -> let_cont , assign .)


state 195

    (39) assign -> lpattern annotation = . conditional
    (59) conditional -> . compound
    (60) conditional -> . IF conditional THEN conditional ELSE conditional
    (61) compound -> . expression
    (62) compound -> . compound infix expression
    (63) compound -> . ( compound infix )
    (64) compound -> . ( infix expression )
    (67) expression -> . multivar
    (68) expression -> . lambda
    (69) expression -> . cond_block
    (76) multivar -> . primaryvar
    (77) multivar -> . rlist
    (78) multivar -> . rtuple
    (79) multivar -> . multivar ( condition_list )
    (74) lambda -> . FDEF ( ) { conditional }
    (75) lambda -> . FDEF ( pattern_list ) { conditional }
    (70) cond_block -> . COND { cond , ELSE : conditional }
    (80) primaryvar -> . ID
    (81) primaryvar -> . [ SPECIALID ]
    (82) primaryvar -> . INTT
    (83) primaryvar -> . FLOATT
    (84) primaryvar -> . CHART
    (85) primaryvar -> . STRINGT
    (86) primaryvar -> . BOOLT
    (87) primaryvar -> . ( conditional )
    (92) rlist -> . [ ]
    (93) rlist -> . [ condition_list ]
    (94) rlist -> . [ conditional | conditional ]
    (95) rlist -> . [ conditional RANGER conditional ]
    (88) rtuple -> . ( )
    (89) rtuple -> . ( rtuple_cont )

    IF              shift and go to state 62
    (               shift and go to state 64
    FDEF            shift and go to state 71
    COND            shift and go to state 72
    ID              shift and go to state 59
    [               shift and go to state 73
    INTT            shift and go to state 74
    FLOATT          shift and go to state 75
    CHART           shift and go to state 76
    STRINGT         shift and go to state 77
    BOOLT           shift and go to state 78

    conditional                    shift and go to state 198
    compound                       shift and go to state 61
    expression                     shift and go to state 63
    multivar                       shift and go to state 65
    lambda                         shift and go to state 66
    cond_block                     shift and go to state 67
    primaryvar                     shift and go to state 68
    rlist                          shift and go to state 69
    rtuple                         shift and go to state 70

state 196

    (75) lambda -> FDEF ( pattern_list ) { conditional } .

    `               reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    SPECIALID       reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    END             reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    ALIAS           reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    LET             reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    FDEF            reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    THEN            reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    )               reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    ,               reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    |               reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    RANGER          reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    ]               reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    }               reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    :               reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)
    ELSE            reduce using rule 75 (lambda -> FDEF ( pattern_list ) { conditional } .)


state 197

    (70) cond_block -> COND { cond , ELSE : conditional . }

    }               shift and go to state 199


state 198

    (39) assign -> lpattern annotation = conditional .

    }               reduce using rule 39 (assign -> lpattern annotation = conditional .)
    ,               reduce using rule 39 (assign -> lpattern annotation = conditional .)


state 199

    (70) cond_block -> COND { cond , ELSE : conditional } .

    `               reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    SPECIALID       reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    END             reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    ALIAS           reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    LET             reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    FDEF            reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    THEN            reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    )               reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    ,               reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    |               reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    RANGER          reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    ]               reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    }               reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    :               reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)
    ELSE            reduce using rule 70 (cond_block -> COND { cond , ELSE : conditional } .)

